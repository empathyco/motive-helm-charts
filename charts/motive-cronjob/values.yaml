# Default values for motive-cronjob.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.



# -- --------------
# Global
# -- --------------



nameOverride: ""
fullnameOverride: ""

# -- How many old ReplicaSets to maintain for the Deployment
# @default -- 3
revisionHistoryLimit: 3

# -- Configuration for imagePullSecrets so that you can use a private registry for your image
## Ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
imagePullSecrets: []

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""
  automountServiceAccountToken: true

  iam:
    enabled: false
    role:
      awsAccountID: ''
      eksClusterOIDCIssuer: ''
      maxSessionDuration: 3600
    policy: ""
#    policy: |
#      {
#        "Version": "2012-10-17",
#        "Statement": [
#           {
#             "Sid": "",
#             "Effect": "Allow",
#             "Action": [
#               "secretsmanager:ListSecretVersionIds",
#               "secretsmanager:GetSecretValue",
#               "secretsmanager:GetResourcePolicy",
#               "secretsmanager:DescribeSecret"
#             ],
#             "Resource": [
#               "arn:aws:secretsmanager:eu-west-1:{{ .Values.serviceAccount.iam.role.awsAccountID }}:secret:*"
#             ]
#           }
#        ]
#      }



# -- --------------
# CronJob
# -- --------------


cronjob:
  # -- Annotations to be added to the controller Deployment or DaemonSet
  annotations: {}

  # -- Labels to be added to the service Deployment or DaemonSet and other resources that do not have option to specify labels
  labels: {}

  # -- `terminationGracePeriodSeconds` to avoid killing pods before we are ready
  ## wait up to 1 minute for the drain of connections
  terminationGracePeriodSeconds: 60

  # -- Configurable annotations applied to all pods
  podAnnotations: {}

  # -- Configurable labels applied to all pods
  podLabels: {}

  # -- Allows you to set the securityContext for the pod
  podSecurityContext: {}
  #  fsGroup: 2000

  # -- See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/ for notes on enabling and using sysctls
  sysctls: {}
  #  "net.core.somaxconn": "8192"

  # -- Allows you to set the securityContext for the main container
  # See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/ for notes on enabling and using sysctls
  containerSecurityContext: {}

  # -- Instruct the kube-scheduler how to place each incoming Pod in relation to the existing Pods across your cluster
  # -- topologySpreadConstraints allows to customize the default topologySpreadConstraints. This can be either a single dict as shown below or a slice of topologySpreadConstraints.
  # labelSelector is taken from the constraint itself (if it exists) or is generated by the chart using the same selectors as for services.
  ## Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
  topologySpreadConstraints:
    maxSkew: 1
    topologyKey: kubernetes.io/hostname
    whenUnsatisfiable: ScheduleAnyway
  #    - maxSkew: 1
  #      labelSelector:
  #        matchLabels:
  #          app.kubernetes.io/name: '{{ include "motive-service.name" . }}'
  #          app.kubernetes.io/instance: '{{ .Release.Name }}'
  #          app.kubernetes.io/component: service
  #      topologyKey: topology.kubernetes.io/zone
  #      whenUnsatisfiable: ScheduleAnyway
  #    - maxSkew: 1
  #      labelSelector:
  #        matchLabels:
  #          app.kubernetes.io/name: '{{ include "motive-service.name" . }}'
  #          app.kubernetes.io/instance: '{{ .Release.Name }}'
  #          app.kubernetes.io/component: service
  #      topologyKey: kubernetes.io/hostname
  #      whenUnsatisfiable: ScheduleAnyway

  # -- Labels of the node(s) where the application pods are allowed to be executed in. Empty means 'any available node'
  # https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
  nodeSelector:
    kubernetes.io/os: linux

  # -- If the application needs to run on tainted nodes, the application needs to have the corresponding tolerations, so kubernetes can schedule to the tainted nodes.
  # If the application is required to run on specific nodes that are tainted, configure also nodeSelector.
  # https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
  tolerations: []
  #  - key: "key"
  #    operator: "Equal|Exists"
  #    value: "value"
  #    effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"

  ## Pod anti-affinity can prevent the scheduler from placing service replicas on the same node.
  ## The default value "soft" means that the scheduler should *prefer* to not schedule two replica pods onto the same node but no guarantee is provided.
  ## The value "hard" means that the scheduler is *required* to not schedule two replica pods onto the same node.
  ## The value "" will disable pod anti-affinity so that no anti-affinity rules will be configured.
  ##
  podAntiAffinity: "hard"

  ## If anti-affinity is enabled sets the topologyKey to use for anti-affinity.
  ## This can be changed to, for example, failure-domain.beta.kubernetes.io/zone
  ##
  podAntiAffinityTopologyKey: kubernetes.io/hostname

  # -- Similar to the nodeSelector, but slightly different:
  # https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
  affinity: {}
  # nodeAffinity:
  #   requiredDuringSchedulingIgnoredDuringExecution:
  #     nodeSelectorTerms:
  #     - matchExpressions:
  #       - key: kubernetes.io/e2e-az-name
  #         operator: In
  #         values:
  #         - e2e-az1
  #         - e2e-az2

  image:
    # -- Docker image repository
    repository: hello-world
    # -- The Kubernetes imagePullPolicy value
    pullPolicy: IfNotPresent
    # -- Overrides the image tag whose default is the chart appVersion.
    tag: latest

  resources:
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    requests:
      # -- CPU requests for the Deployment
      cpu: 100m
      # -- Memory requests for the Deployment
      memory: 256Mi
    limits: {}
      # -- CPU limits for the Deployment
      # cpu: 500m
      # -- Memory limits for the Deployment
      # memory: 512Mi

  # -- Improve connection draining when ingress controller pod is deleted using a lifecycle hook:
  lifecycle:
  #  preStop:
  #    exec:
  #      command:
  #        - /wait-shutdown

  env: []
    # - name: NAME
    #   valueFrom:
    #     secretKeyRef:
    #       name: KEY_NAME
    #       key: SECRET_KEY

  extraEnv: []
    # - name: NAME
    #   valueFrom:
    #     secretKeyRef:
    #       name: KEY_NAME
    #       key: SECRET_KEY

  envFrom: []
    # - secretRef:
    #     name: secret-name
    # - configMapRef:
    #     name: config-map-name

  # -- ------
  # Storage
  # -- ------

  # -- Additional volumes to the controller pod.
  extraVolumes: []
  #  - name: copy-portal-skins
  #    emptyDir: {}

  # -- Additional volumeMounts to the service main container.
  extraVolumeMounts: []
  #  - name: copy-portal-skins
  #   mountPath: /var/lib/lemonldap-ng/portal/skins

  # -- --------------
  # Init Containers
  # -- --------------

  # -- Containers, which are run before the app containers are started.
  extraInitContainers: []
  # - name: init-myservice
  #   image: busybox
  #   command: ['sh', '-c', 'until nslookup myservice; do echo waiting for myservice; sleep 2; done;']

  # -- The schedule in cron format
  schedule: "0 0 * * *"
  # -- The time zone https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
  timeZone: "Etc/UTC"
  # -- Specifies how to treat concurrent executions of a Job
  concurrencyPolicy: Forbid
  # -- Optional deadline in seconds for starting the job
  startingDeadlineSeconds:
  # -- This flag tells the controller to suspend subsequent executions
  suspend: 'false'
  # -- The number of successful finished jobs to retain
  successfulJobsHistoryLimit: 3
  # -- The number of failed finished jobs to retain
  failedJobsHistoryLimit: 1

  job:
    # -- Specifies the maximum desired number of pods the job should run at any given time
    parallelism: 1
    # -- Specifies the desired number of successfully finished pods the job should be run with
    completions: 1
    # -- CompletionMode specifies how Pod completions are tracked
    completionMode: NonIndexed
    # -- Specifies the number of retries before marking this job failed
    backoffLimit: 3
    # -- Specifies the duration in seconds relative to the startTime that the job may be continuously active before the system tries to terminate it
    activeDeadlineSeconds: 3600
    # -- ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed)
    ttlSecondsAfterFinished: 86400
    # -- Suspend specifies whether the Job controller should create Pods or not
    suspend: 'false'
    # -- Restart policy for all containers within the pod
    restartPolicy: OnFailure

    # -- Entrypoint array
    # @default -- `[]`
    command: []
    # - /bin/sh
    # - -c
    # -- Arguments to the entrypoint
    # @default -- `[]`
    args: []
    # - date; echo Hello from the Kubernetes cluster



# -- --------------
# External Secrets
# -- --------------


externalSecrets:
  secretStores: []
  #    - name: "test"
  #      kind: "SecretStore|ClusterSecretStore"
  #      labels: {}
  #      annotations: {}
  #      provider:
  #        aws:
  #          service: "SecretsManager|ParameterStore"
  #          region: ""
  #          role: ""

  externalSecrets: []
#    - name: "test"
#      labels: {}
#      annotations: {}
#      refreshInterval: 1h
#      secretStoreRefName: "test"
#      secretStoreRefKind: "SecretStore|ClusterSecretStore"
#      targetCreationPolicy: "Owner|Merge|None"
#      targetDeletionPolicy: "Delete|Merge|Retain"
#      targetImmutable: false
#      data:
#        - secretKey: username
#          remoteRef:
#            key: database-credentials
#            version: v1
#            property: username
#            decodingStrategy: "None|Base64|Base64URL|Auto"
#      dataFrom: {}